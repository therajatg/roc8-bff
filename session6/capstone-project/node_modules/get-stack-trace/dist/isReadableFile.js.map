{"version":3,"sources":["../src/isReadableFile.js"],"names":["fileAccessCache","filePath","accessable","undefined","fs","accessSync","constants","R_OK","error"],"mappings":";;;;;;;AAEA;;;;AAEA,MAAMA,eAGL,GAAG,EAHJ;;uBAKgBC,Q,IAA8B;AAC5C;AACA;AACA,MAAIC,UAAU,GAAGF,eAAe,CAACC,QAAD,CAAhC;;AAEA,MAAIC,UAAU,KAAKC,SAAnB,EAA8B;AAC5B,WAAOD,UAAP;AACD;;AAED,MAAI;AACFE,gBAAGC,UAAH,CAAcJ,QAAd,EAAwBG,YAAGE,SAAH,CAAaC,IAArC;;AAEAL,IAAAA,UAAU,GAAG,IAAb;AACD,GAJD,CAIE,OAAOM,KAAP,EAAc;AACdN,IAAAA,UAAU,GAAG,KAAb;AACD;;AAEDF,EAAAA,eAAe,CAACC,QAAD,CAAf,GAA4BC,UAA5B;AAEA,SAAOA,UAAP;AACD,C","sourcesContent":["// @flow\n\nimport fs from 'fs';\n\nconst fileAccessCache: {\n  [string]: boolean | typeof undefined,\n  ...\n} = {};\n\nexport default (filePath: string): boolean => {\n  // If the file was previously unreadable, we can assume this\n  // will always be the case\n  let accessable = fileAccessCache[filePath];\n\n  if (accessable !== undefined) {\n    return accessable;\n  }\n\n  try {\n    fs.accessSync(filePath, fs.constants.R_OK);\n\n    accessable = true;\n  } catch (error) {\n    accessable = false;\n  }\n\n  fileAccessCache[filePath] = accessable;\n\n  return accessable;\n};\n"],"file":"isReadableFile.js"}